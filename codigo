#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// Definição da estrutura do nó da lista de reprodução de músicas
typedef struct MusicNode {
    char artist[262];  // Nome do artista
    char song[262];    // Título da música
    struct MusicNode* next;  // Ponteiro para o próximo nó
    struct MusicNode* prev;  // Ponteiro para o nó anterior
} MusicNode;
// Definição da lista circular duplamente encadeada para armazenar as músicas
typedef struct {
    MusicNode* head;    // Ponteiro para o primeiro nó da lista
    MusicNode* current; // Ponteiro para o nó atual na reprodução
    int size;           // Tamanho atual da lista de músicas
} CircularDoublyLinkedList;
// Função para criar um novo nó na lista de músicas
MusicNode* create_music_node(const char* artist, const char* song) {
    MusicNode* new_node = (MusicNode*)malloc(sizeof(MusicNode)); // Alocando memória para o novo nó
    strcpy(new_node->artist, artist);  // Copiando o nome do artista para o novo nó
    strcpy(new_node->song, song);      // Copiando o título da música para o novo nó
    new_node->next = new_node->prev = NULL;  // Inicializando os ponteiros next e prev como NULL
    return new_node;  // Retornando o novo nó criado
}
// Função para criar uma nova lista de músicas
CircularDoublyLinkedList* create_music_list() {
    CircularDoublyLinkedList* list = (CircularDoublyLinkedList*)malloc(sizeof(CircularDoublyLinkedList)); // Alocando memória para a lista
    list->head = list->current = NULL;  // Inicializando os ponteiros head e current como NULL
    list->size = 0;  // Inicializando o tamanho da lista como 0
    return list;  // Retornando a lista criada
}
// Função para adicionar uma nova música à lista de reprodução
void append(CircularDoublyLinkedList* list, const char* artist, const char* song) {
    MusicNode* new_node = create_music_node(artist, song); // Criando um novo nó para a música
    if (list->size == 0) {  // Verificando se a lista está vazia
        list->head = list->current = new_node;  // Se estiver vazia, o novo nó será o primeiro e o atual
        new_node->next = new_node->prev = new_node;  // O novo nó aponta para ele mesmo em ambas as direções
    } else {
        MusicNode* tail = list->head->prev;  // Obtendo o último nó da lista
        tail->next = new_node;  // O próximo nó do último nó aponta para o novo nó
        new_node->prev = tail;   // O nó anterior ao novo nó é o último nó
        new_node->next = list->head;  // O próximo nó após o novo nó é o primeiro nó da lista
        list->head->prev = new_node;   // O nó anterior ao primeiro nó da lista é o novo nó
    }
    list->size++;  // Incrementando o tamanho da lista
}
